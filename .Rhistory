rmse = rmse,
activation_function = activation_function,
hidden_layers = hidden_layers,
neurons_per_layer = neurons_per_layer
))
}
# Evaluate neural network models for each configuration
results <- lapply(configurations, function(config) {
train_nn_model(config$hidden_layers, config$neurons_per_layer, config$activation_function, train_data, test_data)
})
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data = train_data, test_data = test_data)
# Select the list of independent variables and the dependent variable
independent_variables <- c(
"avg_bed", "tract_homevalue_2020", "tract_medage_2020", "tract_medincome_2020",
"tract_medincome_2010", "foreclosure_pc_2010", "pct_built_2020_later",
"pct_built_2010_2019", "pct_built_2000_2009", "pct_built_1990_1999",
"pct_built_1980_1989", "pct_built_1970_1979", "pct_built_pre_1960",
"pct_0_bd", "pct_1_bd", "pct_2_bd", "pct_3_bd", "pct_4_more_bd",
"poverty_2010", "poverty_2020", "nhwhite_2010", "nhwhite_2020",
"mortgaged_2010", "mortgaged_2015", "mortgaged_2020", "ownoccupied_2010",
"ownoccupied_2015", "ownoccupied_2020", "mortgage_change_2010_2015",
"mortgage_change_2015_2020", "mortgage_change_2010_2020",
"ownoccupied_change_2010_2015", "ownoccupied_change_2015_2020",
"ownoccupied_change_2010_2020", "poverty_change_2010_2020",
"nhwhite_change_2010_2020", "medincome_change_2010_2015",
"medincome_change_2015_2020", "medincome_change_2010_2020", "pop_change_pct"
)
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Extract the selected columns from the dataframe
selected_data <- pg_foreclosures_per_tract[independent_variables]
# Normalize the selected columns
selected_data_normalized <- selected_data
selected_data_normalized[] <- lapply(selected_data, min_max_scaling)
# Add foreclosure_pc_2020 to the normalized dataframe
selected_data_normalized$foreclosure_pc_2020 <- min_max_scaling(pg_foreclosures_per_tract$foreclosure_pc_2020)
# Split data into training and testing sets
set.seed(123)
train_index <- createDataPartition(selected_data_normalized$foreclosure_pc_2020, p = 0.8, list = FALSE)
train_data <- selected_data_normalized[train_index, ]
test_data <- selected_data_normalized[-train_index, ]
# Define configurations to test
configurations <- list(
list(hidden_layers = 1, neurons_per_layer = c(10), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(10, 5), activation_function = "tanh"),
list(hidden_layers = 1, neurons_per_layer = c(5), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(5, 3), activation_function = "tanh"),
list(hidden_layers = 3, neurons_per_layer = c(8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 3, neurons_per_layer = c(12, 8, 4), activation_function = "tanh"),
list(hidden_layers = 4, neurons_per_layer = c(10, 8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 4, neurons_per_layer = c(12, 10, 6, 3), activation_function = "tanh"),
list(hidden_layers = 2, neurons_per_layer = c(8, 6), activation_function = "relu"),
list(hidden_layers = 3, neurons_per_layer = c(15, 10, 5), activation_function = "relu"),
list(hidden_layers = 2, neurons_per_layer = c(15, 8), activation_function = "linear"),
list(hidden_layers = 3, neurons_per_layer = c(10, 8, 6), activation_function = "linear")
)
# Function to build and train neural network model
train_nn_model <- function(hidden_layers, neurons_per_layer, activation_function, train_data, test_data) {
# Build neural network model
model <- neuralnet(
foreclosure_pc_2020 ~ .,
data = train_data,  # Use normalized training data
hidden = neurons_per_layer,
linear.output = TRUE,  # For regression tasks
act.fct = activation_function
)
# Make predictions on test data
predictions <- predict(model, test_data)
# Calculate evaluation metrics (e.g., RMSE)
rmse <- sqrt(mean((test_data$foreclosure_pc_2020 - predictions)^2))
# Return performance results
return(list(
rmse = rmse,
activation_function = activation_function,
hidden_layers = hidden_layers,
neurons_per_layer = neurons_per_layer
))
}
# Evaluate neural network models for each configuration
results <- lapply(configurations, function(config) {
train_nn_model(config$hidden_layers, config$neurons_per_layer, config$activation_function, train_data, test_data)
})
# Select the list of independent variables and the dependent variable
independent_variables <- c(
"avg_bed", "tract_homevalue_2020", "tract_medage_2020", "tract_medincome_2020",
"tract_medincome_2010", "foreclosure_pc_2010", "pct_built_2020_later",
"pct_built_2010_2019", "pct_built_2000_2009", "pct_built_1990_1999",
"pct_built_1980_1989", "pct_built_1970_1979", "pct_built_pre_1960",
"pct_0_bd", "pct_1_bd", "pct_2_bd", "pct_3_bd", "pct_4_more_bd",
"poverty_2010", "poverty_2020", "nhwhite_2010", "nhwhite_2020",
"mortgaged_2010", "mortgaged_2015", "mortgaged_2020", "ownoccupied_2010",
"ownoccupied_2015", "ownoccupied_2020", "mortgage_change_2010_2015",
"mortgage_change_2015_2020", "mortgage_change_2010_2020",
"ownoccupied_change_2010_2015", "ownoccupied_change_2015_2020",
"ownoccupied_change_2010_2020", "poverty_change_2010_2020",
"nhwhite_change_2010_2020", "medincome_change_2010_2015",
"medincome_change_2015_2020", "medincome_change_2010_2020", "pop_change_pct"
)
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Extract the selected columns from the dataframe
selected_data <- pg_foreclosures_per_tract[independent_variables]
# Normalize the selected columns
selected_data_normalized <- selected_data
selected_data_normalized[] <- lapply(selected_data, min_max_scaling)
# Add foreclosure_pc_2020 to the normalized dataframe
selected_data_normalized$foreclosure_pc_2020 <- min_max_scaling(pg_foreclosures_per_tract$foreclosure_pc_2020)
# Split data into training and testing sets
set.seed(123)
train_index <- createDataPartition(selected_data_normalized$foreclosure_pc_2020, p = 0.8, list = FALSE)
train_data <- selected_data_normalized[train_index, ]
test_data <- selected_data_normalized[-train_index, ]
# Define configurations to test
configurations <- list(
list(hidden_layers = 1, neurons_per_layer = c(10), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(10, 5), activation_function = "tanh"),
list(hidden_layers = 1, neurons_per_layer = c(5), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(5, 3), activation_function = "tanh"),
list(hidden_layers = 3, neurons_per_layer = c(8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 3, neurons_per_layer = c(12, 8, 4), activation_function = "tanh"),
list(hidden_layers = 4, neurons_per_layer = c(10, 8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 4, neurons_per_layer = c(12, 10, 6, 3), activation_function = "tanh")
)
# Function to build and train neural network model
train_nn_model <- function(hidden_layers, neurons_per_layer, activation_function, train_data, test_data) {
# Build neural network model
model <- neuralnet(
foreclosure_pc_2020 ~ .,
data = train_data,  # Use normalized training data
hidden = neurons_per_layer,
linear.output = TRUE,  # For regression tasks
act.fct = activation_function
)
# Make predictions on test data
predictions <- predict(model, test_data)
# Calculate evaluation metrics (e.g., RMSE)
rmse <- sqrt(mean((test_data$foreclosure_pc_2020 - predictions)^2))
# Return performance results
return(list(
rmse = rmse,
activation_function = activation_function,
hidden_layers = hidden_layers,
neurons_per_layer = neurons_per_layer
))
}
# Evaluate neural network models for each configuration
results <- lapply(configurations, function(config) {
train_nn_model(config$hidden_layers, config$neurons_per_layer, config$activation_function, train_data, test_data)
})
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data = train_data, test_data = test_data)
# Select the list of independent variables and the dependent variable
independent_variables <- c(
"avg_bed", "tract_homevalue_2020", "tract_medage_2020", "tract_medincome_2020",
"tract_medincome_2010", "foreclosure_pc_2010", "pct_built_2020_later",
"pct_built_2010_2019", "pct_built_2000_2009", "pct_built_1990_1999",
"pct_built_1980_1989", "pct_built_1970_1979", "pct_built_pre_1960",
"pct_0_bd", "pct_1_bd", "pct_2_bd", "pct_3_bd", "pct_4_more_bd",
"poverty_2010", "poverty_2020", "nhwhite_2010", "nhwhite_2020",
"mortgaged_2010", "mortgaged_2015", "mortgaged_2020", "ownoccupied_2010",
"ownoccupied_2015", "ownoccupied_2020", "mortgage_change_2010_2015",
"mortgage_change_2015_2020", "mortgage_change_2010_2020",
"ownoccupied_change_2010_2015", "ownoccupied_change_2015_2020",
"ownoccupied_change_2010_2020", "poverty_change_2010_2020",
"nhwhite_change_2010_2020", "medincome_change_2010_2015",
"medincome_change_2015_2020", "medincome_change_2010_2020", "pop_change_pct"
)
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Extract the selected columns from the dataframe
selected_data <- pg_foreclosures_per_tract[independent_variables]
# Normalize the selected columns
selected_data_normalized <- selected_data
selected_data_normalized[] <- lapply(selected_data, min_max_scaling)
# Add foreclosure_pc_2020 to the normalized dataframe
selected_data_normalized$foreclosure_pc_2020 <- min_max_scaling(pg_foreclosures_per_tract$foreclosure_pc_2020)
# Split data into training and testing sets
set.seed(123)
train_index <- createDataPartition(selected_data_normalized$foreclosure_pc_2020, p = 0.8, list = FALSE)
train_data <- selected_data_normalized[train_index, ]
test_data <- selected_data_normalized[-train_index, ]
# Define configurations to test
configurations <- list(
list(hidden_layers = 1, neurons_per_layer = c(10), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(10, 5), activation_function = "tanh"),
list(hidden_layers = 1, neurons_per_layer = c(5), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(5, 3), activation_function = "tanh"),
list(hidden_layers = 3, neurons_per_layer = c(8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 3, neurons_per_layer = c(12, 8, 4), activation_function = "tanh"),
list(hidden_layers = 4, neurons_per_layer = c(10, 8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 4, neurons_per_layer = c(12, 10, 6, 3), activation_function = "tanh"),
list(hidden_layers = 2, neurons_per_layer = c(8, 6), activation_function = "relu"),
list(hidden_layers = 3, neurons_per_layer = c(15, 10, 5), activation_function = "relu"),
list(hidden_layers = 2, neurons_per_layer = c(15, 8), activation_function = "linear"),
list(hidden_layers = 3, neurons_per_layer = c(10, 8, 6), activation_function = "linear")
)
# Function to build and train neural network model
train_nn_model <- function(hidden_layers, neurons_per_layer, activation_function, train_data, test_data) {
# Build neural network model
model <- neuralnet(
foreclosure_pc_2020 ~ .,
data = train_data,  # Use normalized training data
hidden = neurons_per_layer,
linear.output = TRUE,  # For regression tasks
act.fct = activation_function
)
# Make predictions on test data
predictions <- predict(model, test_data)
# Calculate evaluation metrics (e.g., RMSE)
rmse <- sqrt(mean((test_data$foreclosure_pc_2020 - predictions)^2))
# Return performance results
return(list(
rmse = rmse,
activation_function = activation_function,
hidden_layers = hidden_layers,
neurons_per_layer = neurons_per_layer
))
}
# Evaluate neural network models for each configuration
results <- lapply(configurations, function(config) {
train_nn_model(config$hidden_layers, config$neurons_per_layer, config$activation_function, train_data, test_data)
})
# Select the list of independent variables and the dependent variable
independent_variables <- c(
"avg_bed", "tract_homevalue_2020", "tract_medage_2020", "tract_medincome_2020",
"tract_medincome_2010", "foreclosure_pc_2010", "pct_built_2020_later",
"pct_built_2010_2019", "pct_built_2000_2009", "pct_built_1990_1999",
"pct_built_1980_1989", "pct_built_1970_1979", "pct_built_pre_1960",
"pct_0_bd", "pct_1_bd", "pct_2_bd", "pct_3_bd", "pct_4_more_bd",
"poverty_2010", "poverty_2020", "nhwhite_2010", "nhwhite_2020",
"mortgaged_2010", "mortgaged_2015", "mortgaged_2020", "ownoccupied_2010",
"ownoccupied_2015", "ownoccupied_2020", "mortgage_change_2010_2015",
"mortgage_change_2015_2020", "mortgage_change_2010_2020",
"ownoccupied_change_2010_2015", "ownoccupied_change_2015_2020",
"ownoccupied_change_2010_2020", "poverty_change_2010_2020",
"nhwhite_change_2010_2020", "medincome_change_2010_2015",
"medincome_change_2015_2020", "medincome_change_2010_2020", "pop_change_pct"
)
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Extract the selected columns from the dataframe
selected_data <- pg_foreclosures_per_tract[independent_variables]
# Normalize the selected columns
selected_data_normalized <- selected_data
selected_data_normalized[] <- lapply(selected_data, min_max_scaling)
# Add foreclosure_pc_2020 to the normalized dataframe
selected_data_normalized$foreclosure_pc_2020 <- min_max_scaling(pg_foreclosures_per_tract$foreclosure_pc_2020)
# Split data into training and testing sets
set.seed(123)
train_index <- createDataPartition(selected_data_normalized$foreclosure_pc_2020, p = 0.8, list = FALSE)
train_data <- selected_data_normalized[train_index, ]
test_data <- selected_data_normalized[-train_index, ]
# Define configurations to test
configurations <- list(
list(hidden_layers = 1, neurons_per_layer = c(10), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(10, 5), activation_function = "tanh"),
list(hidden_layers = 1, neurons_per_layer = c(5), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(5, 3), activation_function = "tanh"),
list(hidden_layers = 3, neurons_per_layer = c(8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 3, neurons_per_layer = c(12, 8, 4), activation_function = "tanh"),
list(hidden_layers = 4, neurons_per_layer = c(10, 8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 4, neurons_per_layer = c(12, 10, 6, 3), activation_function = "tanh")
)
# Function to build and train neural network model
train_nn_model <- function(hidden_layers, neurons_per_layer, activation_function, train_data, test_data) {
# Build neural network model
model <- neuralnet(
foreclosure_pc_2020 ~ .,
data = train_data,  # Use normalized training data
hidden = neurons_per_layer,
linear.output = TRUE,  # For regression tasks
act.fct = activation_function
)
# Make predictions on test data
predictions <- predict(model, test_data)
# Calculate evaluation metrics (e.g., RMSE)
rmse <- sqrt(mean((test_data$foreclosure_pc_2020 - predictions)^2))
# Return performance results
return(list(
rmse = rmse,
activation_function = activation_function,
hidden_layers = hidden_layers,
neurons_per_layer = neurons_per_layer
))
}
# Evaluate neural network models for each configuration
results <- lapply(configurations, function(config) {
train_nn_model(config$hidden_layers, config$neurons_per_layer, config$activation_function, train_data, test_data)
})
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data = train_data, test_data = test_data)
# Select the list of independent variables and the dependent variable
independent_variables <- c(
"avg_bed", "tract_homevalue_2020", "tract_medage_2020", "tract_medincome_2020",
"tract_medincome_2010", "foreclosure_pc_2010", "pct_built_2020_later",
"pct_built_2010_2019", "pct_built_2000_2009", "pct_built_1990_1999",
"pct_built_1980_1989", "pct_built_1970_1979", "pct_built_pre_1960",
"pct_0_bd", "pct_1_bd", "pct_2_bd", "pct_3_bd", "pct_4_more_bd",
"poverty_2010", "poverty_2020", "nhwhite_2010", "nhwhite_2020",
"mortgaged_2010", "mortgaged_2015", "mortgaged_2020", "ownoccupied_2010",
"ownoccupied_2015", "ownoccupied_2020", "mortgage_change_2010_2015",
"mortgage_change_2015_2020", "mortgage_change_2010_2020",
"ownoccupied_change_2010_2015", "ownoccupied_change_2015_2020",
"ownoccupied_change_2010_2020", "poverty_change_2010_2020",
"nhwhite_change_2010_2020", "medincome_change_2010_2015",
"medincome_change_2015_2020", "medincome_change_2010_2020", "pop_change_pct"
)
min_max_scaling <- function(x) {
(x - min(x)) / (max(x) - min(x))
}
# Extract the selected columns from the dataframe
selected_data <- pg_foreclosures_per_tract[independent_variables]
# Normalize the selected columns
selected_data_normalized <- selected_data
selected_data_normalized[] <- lapply(selected_data, min_max_scaling)
# Add foreclosure_pc_2020 to the normalized dataframe
selected_data_normalized$foreclosure_pc_2020 <- min_max_scaling(pg_foreclosures_per_tract$foreclosure_pc_2020)
# Split data into training and testing sets
set.seed(123)
train_index <- createDataPartition(selected_data_normalized$foreclosure_pc_2020, p = 0.8, list = FALSE)
train_data <- selected_data_normalized[train_index, ]
test_data <- selected_data_normalized[-train_index, ]
# Define configurations to test
configurations <- list(
list(hidden_layers = 1, neurons_per_layer = c(10), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(10, 5), activation_function = "tanh"),
list(hidden_layers = 1, neurons_per_layer = c(5), activation_function = "logistic"),
list(hidden_layers = 2, neurons_per_layer = c(5, 3), activation_function = "tanh"),
list(hidden_layers = 3, neurons_per_layer = c(8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 3, neurons_per_layer = c(12, 8, 4), activation_function = "tanh"),
list(hidden_layers = 4, neurons_per_layer = c(10, 8, 6, 4), activation_function = "logistic"),
list(hidden_layers = 4, neurons_per_layer = c(12, 10, 6, 3), activation_function = "tanh"),
list(hidden_layers = 5, neurons_per_layer = c(15, 12, 10, 8, 6), activation_function = "logistic"),
list(hidden_layers = 5, neurons_per_layer = c(20, 15, 12, 8, 5), activation_function = "tanh")
)
# Function to build and train neural network model
train_nn_model <- function(hidden_layers, neurons_per_layer, activation_function, train_data, test_data) {
# Build neural network model
model <- neuralnet(
foreclosure_pc_2020 ~ .,
data = train_data,  # Use normalized training data
hidden = neurons_per_layer,
linear.output = TRUE,  # For regression tasks
act.fct = activation_function
)
# Make predictions on test data
predictions <- predict(model, test_data)
# Calculate evaluation metrics (e.g., RMSE)
rmse <- sqrt(mean((test_data$foreclosure_pc_2020 - predictions)^2))
# Return performance results
return(list(
rmse = rmse,
activation_function = activation_function,
hidden_layers = hidden_layers,
neurons_per_layer = neurons_per_layer
))
}
# Evaluate neural network models for each configuration
results <- lapply(configurations, function(config) {
train_nn_model(config$hidden_layers, config$neurons_per_layer, config$activation_function, train_data, test_data)
})
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data = train_data, test_data = test_data)
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data = train_data, test_data = test_data)
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data, test_data)
# Plot the best neural network model
plot_nn_model(best_model$model)
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data, test_data)
# Function to plot the neural network model
plot_nn_model <- function(model) {
plot(model, rep = "best")
}
# Plot the best neural network model
plot_nn_model(best_model$model)
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data, test_data)
# Function to plot the neural network model
plot_nn_model <- function(model) {
plot(model, rep = "best", xlim = c(0, 1), ylim = c(0, 1))
}
# Plot the best neural network model
plot_nn_model(best_model$model)
# Report results
for (i in seq_along(results)) {
cat("Configuration:", i, "\n")
cat("RMSE:", results[[i]]$rmse, "\n")
cat("Activation Function:", results[[i]]$activation_function, "\n")
cat("Hidden Layers:", results[[i]]$hidden_layers, "\n")
cat("Neurons per Layer:", results[[i]]$neurons_per_layer, "\n\n")
}
# Identify the best configuration based on performance metrics
best_config <- configurations[[which.min(sapply(results, function(x) x$rmse))]]
# Train the best model with the identified configuration
best_model <- train_nn_model(best_config$hidden_layers, best_config$neurons_per_layer, best_config$activation_function, train_data, test_data)
# Plot the neural network model
plot(best_model$model)
# Filter Method for SVM
library(caret)
# Perform correlation-based feature selection
selected_features <- findCorrelation(cor(train_data[, -which(names(train_data) == "foreclosure_pc_2020")]), cutoff = 0.8)
# Train SVM model with selected features
svm_model_filtered <- svm(foreclosure_pc_2020 ~ ., data = train_data[, selected_features], kernel = "linear")
# Wrapper Method for Naive Bayes
library(caret)
# Perform recursive feature elimination
control <- rfeControl(functions = nbFuncs, method = "cv", number = 10)
naive_bayes_rfe <- rfe(train_data_2[, -which(names(train_data_2) == "foreclosure_quantile")],
train_data_2$foreclosure_quantile,
sizes = c(1:10),
rfeControl = control)
# Embedded Method for Linear Regression
library(glmnet)
# Fit LASSO model
lasso_model <- cv.glmnet(as.matrix(train_data_multivariate_1[, test_variables_3]),
train_data_multivariate_1$foreclosure_pc_2020,
alpha = 1)
# Filter Method for SVM
library(caret)
# Ensure 'foreclosure_pc_2020' is included in train_data
train_data <- cbind(train_data, foreclosure_pc_2020 = pg_foreclosures_per_tract[train_index, "foreclosure_pc_2020"])
# Perform correlation-based feature selection
selected_features <- findCorrelation(cor(train_data[, -which(names(train_data) == "foreclosure_pc_2020")]), cutoff = 0.8)
# Train SVM model with selected features
svm_model_filtered <- svm(foreclosure_pc_2020 ~ ., data = train_data[, selected_features], kernel = "linear")
